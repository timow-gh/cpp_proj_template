set(HEADER_FILES
        ${CMAKE_CURRENT_LIST_DIR}/include/example_library/library.hpp
)

set(SOURCE_FILES
        ${CMAKE_CURRENT_LIST_DIR}/source/library.cpp
)

# Use prefix for the lib name, that is project specific. This is required to avoid name clashes with other libraries.
# CMake requires unique target names. If this project is added as a subdirectory to another project, the target names
# must not clash with the target names of any other project.
set(TARGET_NAME cppprojtemplate_example_library)
# Don't use STATIC ore SHARED for the library, the user should decide by setting the BUILD_SHARED_LIBS
# variable when building this library
add_library(${TARGET_NAME} ${SOURCE_FILES} ${HEADER_FILES})

# "EXPORT_NAME: Exported name for target files.
# This sets the name for the IMPORTED target generated by the install(EXPORT) and export() commands. If not set, the
# logical target name is used by default.", CMake docs
set(TARGET_EXPORT_NAME example_library)
set(${TARGET_NAME}_MAJOR 0)
set(${TARGET_NAME}_MINOR 1)
set(${TARGET_NAME}_PATCH 0)

set_target_properties(${TARGET_NAME}
        PROPERTIES
        LANGUAGE CXX
        LINKER_LANGUAGE CXX
        DEBUG_POSTFIX d
        VERSION ${${TARGET_NAME}_MAJOR}.${${TARGET_NAME}_MINOR}.${${TARGET_NAME}_PATCH}
        SOVERSION ${PROJECT_VERSION_MAJOR}
        # OUTPUT_NAME: Name of the target binaries (build and install). If the binary names are not project specific,
        # they may clash with binaries of other projects.
        OUTPUT_NAME "cppprojtemplate_${TARGET_EXPORT_NAME}"
        # EXPORT_NAME: Different target name only when exporting the target. This allows to use a prefix free target name:
        # <PROJECT_NAME>::<TARGET_EXPORT_NAME> instead of <PROJECT_NAME>::<TARGET_NAME>, where <TARGET_NAME> should have a
        # project specific prefix to guard against name clashes.
        EXPORT_NAME ${TARGET_EXPORT_NAME}
)

# Add an alias so that library can be used inside the build tree the same way it is consumed after installation
# All libraries get an alias of the form <PROJECT_NAME>::<TARGET_NAME>
add_library(${PROJECT_NAME}::${TARGET_EXPORT_NAME} ALIAS ${TARGET_NAME})

# Generate the export header for the library. All Symbols that are marked as "exported" in the header files
# will be exported. The export header is generated in the build directory and will be installed with the library.
include(GenerateExportHeader)
generate_export_header(${TARGET_NAME}
        BASE_NAME ${TARGET_EXPORT_NAME}
)
string(TOLOWER "${TARGET_EXPORT_NAME}_export.h" GENERATED_TARGET_EXPORTS_FILE_NAME)
file(COPY
        ${CMAKE_CURRENT_BINARY_DIR}/${GENERATED_TARGET_EXPORTS_FILE_NAME}
        DESTINATION
        ${CMAKE_CURRENT_BINARY_DIR}/export_header_includes/${TARGET_EXPORT_NAME})

target_include_directories(${TARGET_NAME}
        PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/export_header_includes/>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/include>
)
if (${PROJECT_NAME}_USE_WARNINGS)
    add_warnings_and_compile_options(${TARGET_NAME} "${${PROJECT_NAME}_WARNINGS_AS_ERRORS}")
endif ()

if (${PROJECT_NAME}_STATIC_ANALYSIS)
    enable_static_analysis(${TARGET_NAME} "${${PROJECT_NAME}_WARNINGS_AS_ERRORS}")
    include(cppcheck)
    enable_cppcheck(${TARGET_NAME})
endif ()

# The library fmt::fmt is linked private, since the library is not exposed to the user of this library.
target_link_libraries(${TARGET_NAME} PRIVATE fmt::fmt)

if (${PROJECT_NAME}_INSTALL)
    # Install (i.e. copy) the library headers
    install(DIRECTORY "include/${TARGET_EXPORT_NAME}" DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
            COMPONENT MyProj_Development)

    install(FILES "${CMAKE_CURRENT_BINARY_DIR}/${GENERATED_TARGET_EXPORTS_FILE_NAME}"
            DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}/${TARGET_EXPORT_NAME}"
            COMPONENT MyProj_Development)

    # Install the library target
    # ${TARGET_NAME}TargetsExportSet is the name of the export set that is created by the call to install(EXPORT)
    install(TARGETS ${TARGET_NAME} ${deps}
            EXPORT ${project_export_set_name}
            RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
            COMPONENT MyProj_Runtime
            LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
            COMPONENT MyProj_Runtime
            ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
            COMPONENT MyProj_Development
            # CMake doc on INCLUDES DESTINATION:
            # This option specifies a list of directories which will be added to the INTERFACE_INCLUDE_DIRECTORIES
            # target property of the <targets> when exported by the install(EXPORT) command. If a relative path is
            # specified, it is treated as relative to the $<INSTALL_PREFIX>.
            INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
endif ()